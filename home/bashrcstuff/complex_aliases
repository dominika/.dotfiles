function use_local_gem {
  gsed -i "s/gem '$1',/gem '$1', path: '..\/$1' \#/g" Gemfile && bundle update $1
}

function use_original_gem {
  gsed -i "s/gem '$1', path: '..\/$1' \#/gem '$1',/g" Gemfile && bundle update $1
}

function install_ruby() {
  brew upgrade ruby-build
  ruby-build $1 /opt/rubies/ruby-$1
  . ~/.bashrc
  chruby $1
  gem install bundler
}

function 2fafor() {
  oathtool --totp -b $1 | pbcopy
}

function glp() {
  # or -S
  git log -p -G$1
}

function gc() {
  local pivotal_id
  pivotal_id=$(git branch --no-color 2> /dev/null | sed -n 's/^\* .*\/[pt]*\([0-9]*\)\(.*\)/#\1/p')
  git commit -m"$1

[$pivotal_id]"
}

function gpo() {
  git pull origin `parse_git_branch`;
}

function gpuo() {
  git push origin `parse_git_branch`;
}

gemopen() {
  cd `bundle show $1` && v
}

function dut() { 
  du -ch "$@" | grep total;
}

function dus() { 
  du -ah "$@" | sort -rn | more;
}

function dush() { 
  du -hd 1 "$@" | sort -rn | more;
}

function dux() {
  du -hx "$@" | sort -hr | head
}

fgc() {
  local branches branch
  branches=$(git branch -vv) &&
    branch=$(echo "$branches" | fzf +m) &&
    git checkout $(echo "$branch" | awk '{print $1}' | sed "s/.* //")
}

fgcr() {
  local branches branch
  branches=$(git branch --all | grep -v HEAD) &&
    branch=$(echo "$branches" |
             fzf -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
                 git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

fgcc() {
  local commits commit
  commits=$(git log --pretty=oneline --abbrev-commit --reverse) &&
  commit=$(echo "$commits" | fzf --tac +s +m -e) &&
  git checkout $(echo "$commit" | sed "s/ .*//")
}


fshow() {
  local out shas sha q k
  while out=$(
      git log --graph --color=always \
          --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
      fzf --ansi --multi --no-sort --reverse --query="$q" \
          --print-query --expect=ctrl-d); do
    q=$(head -1 <<< "$out")
    k=$(head -2 <<< "$out" | tail -1)
    shas=$(sed '1,2d;s/^[^a-z0-9]*//;/^$/d' <<< "$out" | awk '{print $1}')
    [ -z "$shas" ] && continue
    if [ "$k" = ctrl-d ]; then
      git diff --color=always $shas | less -R
    else
      for sha in $shas; do
        git show --color=always $sha | less -R
      done
    fi
  done
}

fshow_patch() {
  local out stash_id
  while out=$(git stash list | fzf --no-sort); do
    stash_id=$(echo $out | awk -F: '{print $1}')
    [ -z "$stash_id" ] && continue
    git stash show --color=always -p $stash_id | less -R
  done
}
