function sp {
  local notification_message
  local spec_status

  RAILS_ENV=test bundle exec rspec --fail-fast $1
  spec_status=$?
  if [ $spec_status -eq 0 ];then
    notification_message="All passed"
  else
    notification_message="Some failed"
  fi
  echo $notification_message
  osascript -e "display notification \"$notification_message\" with title \"Tests finished\""
}

function _update_ {
  echo 'Updating rubygems  -------------------------------------------------'
  gem update --system
  j admin
  echo 'Updating bundler   -------------------------------------------------'
  gem install bundler --no-document
  # gem cleanup -V
  echo 'Updating homebrew  -------------------------------------------------' 
  if brew update ; then
    echo 'Upgrading homebrew -------------------------------------------------'
    brew upgrade --cleanup
    brew cask upgrade
  fi
  brew doctor
  echo 'Upgrading vim & plugins --------------------------------------------'
  v +PlugUpgrade +PlugUpdate +qall
  #https://github.com/Homebrew/homebrew-bundle
}

function use_local_gem {
  gsed -i "s/gem '$1',/gem '$1', path: '..\/$1' \#/g" Gemfile && bundle update $1 && generate_ctags $(basename $(pwd)) with_gems

}

function use_original_gem {
  gsed -i "s/gem '$1', path: '..\/$1' \#/gem '$1',/g" Gemfile && bundle update $1 && generate_ctags $(basename $(pwd)) with_gems
}

function install_ruby() {
  brew upgrade ruby-build
  ruby-build $1 /opt/rubies/ruby-$1
  . ~/.bashrc
  chruby $1
  gem install bundler
}

function 2fafor() {
  oathtool --totp -b $1 | pbcopy
}

function glp() {
  # or -S
  git log -p -G$1
}

function gc() {
  local pivotal_id
  pivotal_id=$(git branch --no-color 2> /dev/null | sed -n 's/^\* .*\/[pt]*\([0-9]*\)\(.*\)/#\1/p')
  git commit -m"$1" -m"[$pivotal_id]"
}

function gpo() {
  git pull origin `parse_git_branch`;
}

function gpuo() {
  git push origin `parse_git_branch`;
}

gemopen() {
  cd `bundle show $1` && v
}

function dut() { 
  du -ch "$@" | grep total;
}

function dus() { 
  du -ah "$@" | sort -rn | more;
}

function dush() { 
  du -hd 1 "$@" | sort -rn | more;
}

function dux() {
  du -hx "$@" | sort -hr | head
}

fgc() {
  local branches branch
  branches=$(git branch -vv) &&
    branch=$(echo "$branches" | fzf +m) &&
    git checkout $(echo "$branch" | awk '{print $1}' | sed "s/.* //")
}

fgcr() {
  local branches branch
  branches=$(git branch --all | grep -v HEAD) &&
    branch=$(echo "$branches" |
             fzf -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
                 git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

fgcc() {
  local commits commit
  commits=$(git log --pretty=oneline --abbrev-commit --reverse) &&
  commit=$(echo "$commits" | fzf --tac +s +m -e) &&
  git checkout $(echo "$commit" | sed "s/ .*//")
}


fshow() {
  local out shas sha q k
  while out=$(
      git log --graph --color=always \
          --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
      fzf --ansi --multi --no-sort --reverse --query="$q" \
          --print-query --expect=ctrl-d); do
    q=$(head -1 <<< "$out")
    k=$(head -2 <<< "$out" | tail -1)
    shas=$(sed '1,2d;s/^[^a-z0-9]*//;/^$/d' <<< "$out" | awk '{print $1}')
    [ -z "$shas" ] && continue
    if [ "$k" = ctrl-d ]; then
      git diff --color=always $shas | less -R
    else
      for sha in $shas; do
        git show --color=always $sha | less -R
      done
    fi
  done
}

fshow_patch() {
  local out stash_id
  while out=$(git stash list | fzf --no-sort); do
    stash_id=$(echo $out | awk -F: '{print $1}')
    [ -z "$stash_id" ] && continue
    git stash show --color=always -p $stash_id | less -R
  done
}
